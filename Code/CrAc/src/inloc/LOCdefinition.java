package inloc;

import java.util.ArrayList;
import java.util.List;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlSchemaType;
import javax.xml.bind.annotation.XmlType;

/**
 * The sketch of this class was generated by JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.4-2,
 * based on the InLOC xsd.
 * 
 * LOCdefinition represents the formulation in words of a distinct LOC concept.
 * 
 * for further reading please visit http://www.cetis.org.uk/inloc/coarse/IM.html#LOCdefinition
 * 
 * @author Florian Jungwirth, Michaela Murauer
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "LOCdefinition", propOrder = { "primaryStructure" })
public class LOCdefinition extends LOCtypeLOC {

	@XmlSchemaType(name = "anyURI")
	protected String primaryStructure;

	/**
	 * Gets the value of the primaryStructure property.
	 * 
	 * @return possible object is {@link String }
	 * 
	 */
	public String getPrimaryStructure() {
		return primaryStructure;
	}

	/**
	 * Sets the value of the primaryStructure property.
	 * 
	 * @param value
	 *            allowed object is {@link String }
	 * 
	 */
	public void setPrimaryStructure(String value) {
		this.primaryStructure = value;
	}

	public List<LOCstructure> getTopLevelStructures() {
		List<LOCstructure> currentTopLevelStructures = new ArrayList<LOCstructure>();
		for (LOCrel parentRel : parents) {
			if (parentRel.getScheme() == LOCscheme.isPartOf
					|| parentRel.getScheme() == LOCscheme.isDefinedLevelOf
					|| parentRel.getScheme() == LOCscheme.isExampleOf) {
				if (parentRel.getLocType() instanceof LOCstructure) {
					if(!((LOCstructure)parentRel.getLocType()).getLevels().containsValue(this))
						if(!currentTopLevelStructures.contains(this))
							currentTopLevelStructures.add((LOCstructure) parentRel.getLocType());
				} else {
					List<LOCstructure> parentsTopLevelStructures = ((LOCdefinition) parentRel.getLocType())
									.getTopLevelStructures();
					for(LOCstructure locStruct : parentsTopLevelStructures) {
						if(!currentTopLevelStructures.contains(locStruct))
							currentTopLevelStructures.add(locStruct);
					}
				}
			}
		}
		return currentTopLevelStructures;
	}
	
	public List<LOCdefinition> getTopLevelDefinitions() {
		List<LOCdefinition> currentTopLevelDefinitions = new ArrayList<LOCdefinition>();
		for (LOCrel parentRel : parents) {
			if (parentRel.getScheme() == LOCscheme.isPartOf
					|| parentRel.getScheme() == LOCscheme.isDefinedLevelOf
					|| parentRel.getScheme() == LOCscheme.isExampleOf) {
				if (parentRel.getLocType() instanceof LOCstructure) {
					if(!((LOCstructure)parentRel.getLocType()).getLevels().containsValue(this))
						if(!currentTopLevelDefinitions.contains(this))
							currentTopLevelDefinitions.add(this);
				} else {
					List<LOCdefinition> parentsTopLevelDefinitions = ((LOCdefinition) parentRel.getLocType())
									.getTopLevelDefinitions();
					for(LOCdefinition locDef : parentsTopLevelDefinitions) {
						if(!currentTopLevelDefinitions.contains(locDef))
							currentTopLevelDefinitions.add(locDef);
					}
				}
			}
		}
		return currentTopLevelDefinitions;
	}
	
	public int getNumberOfChildren(boolean rekursive) {
		if(!rekursive) {
			return this.childs.size();
		} else {
			int size = childs.size();
			for(LOCrel child : childs) {
				size += ((LOCdefinition)child.getLocType()).getNumberOfChildren(rekursive);
			}
			return size;
		}
	}
}
